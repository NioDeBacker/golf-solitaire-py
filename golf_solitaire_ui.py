import os
from golf_solitaire import GolfGame, Card, Pile
import pygame

CARD_WIDTH = 34
CARD_HEIGHT = 58

class CardObject:
    def __init__(self, card: Card):
        self.x = 0
        self.y = 0
        self.being_dragged = False
        self.card = card

    def is_colliding(self, cord: pygame.Vector2) -> bool:
        return self.x <= cord.x < self.x + CARD_WIDTH and self.y <= cord.y < self.y + CARD_HEIGHT

    def move(self, cord: pygame.Vector2):
        self.x = cord.x
        self.y = cord.y
    
    def place(self):
        pass

class PileObject:
    def __init__(self, pile: Pile, x=0, y=0):
        self.x = x
        self.y = y
        self.pile = pile


class TableauController:
    pass

class GolfSolitaireController:
    def __init__(self):
        self.golf_game: GolfGame = GolfGame()
        # init tableau

        # init stockpile

        # init wastepile

    def notify(self):
        pass

class CardController:
    def __init__(self, model: CardObject):
        self.model = model
        
    def notify(self, event: pygame.Event):
        mouse_pos = pygame.Vector2(pygame.mouse.get_pos())

        # Check select
        if event.type == pygame.MOUSEBUTTONDOWN and not self.model.card.hidden:
            print("selecting")
            if self.model.is_colliding(mouse_pos):
                self.model.being_dragged = True
        # Check drag
        if event.type == pygame.MOUSEMOTION and self.model.being_dragged:
            print("dragging")
            self.model.move(mouse_pos)
        # Check release
        if event.type == pygame.MOUSEBUTTONUP and self.model.being_dragged:
            print("releasing")
            self.model.being_dragged = False


class CardView:
    def __init__(self, model: CardObject):
        self.model = model
        self.image = self.load_image()
        # Set a default position (you'd typically pass this in or calculate it)
        self.rect = self.image.get_rect(topleft=(self.model.x, self.model.y))

    def load_image(self):
        # Ensure face and value are strings for filename creation
        face_str = str(self.model.card.face)
        value_str = str(self.model.card.value)
        
        # Construct the filename
        filename = f"card_{face_str}{value_str}.png"
        
        # Create the full path
        image_path = os.path.join('Card_Deck_Sprites', filename) 
        
        try:
            # Load the image
            image = pygame.image.load(image_path).convert_alpha()
            # Scale the image to a standard size (optional, but good for consistency)
            scaled_image = pygame.transform.scale(image, (CARD_WIDTH, CARD_HEIGHT))
            return scaled_image
            
        except pygame.error as e:
            print(f"Error loading image for {filename}: {e}")
            # Return a simple red rectangle as a placeholder if image fails to load
            placeholder = pygame.Surface((CARD_WIDTH, CARD_HEIGHT))
            placeholder.fill((255, 0, 0)) # Red color
            return placeholder
        
    def set_position(self, x, y):
        self.x = x
        self.y = y
        self.rect.topleft = (x, y)

    def draw(self, screen):
        self.rect.topleft = (self.model.x, self.model.y)
        # The image is drawn at the position stored in self.rect
        screen.blit(self.image, self.rect)

class Event:
    """this is a superclass for any events that might be generated by an
    object and sent to the EventManager"""
    def __init__(self):
        self.name = "Generic Event"

class EventManager:
    """this object is responsible for coordinating most communication
    between the Model, View, and Controller."""
    def __init__(self ):
        from weakref import WeakKeyDictionary
        self.listeners = WeakKeyDictionary()

    def RegisterListener( self, listener ):
        self.listeners[ listener ] = 1

    def UnregisterListener( self, listener ):
        if listener in self.listeners.keys():
            del self.listeners[ listener ]

    def Post( self, event ):
        for listener in self.listeners.keys():
            #NOTE: If the weakref has died, it will be 
            #automatically removed, so we don't have 
            #to worry about it.
            listener.notify( event )

# pygame setup
pygame.init()
screen = pygame.display.set_mode((1280, 720))
clock = pygame.time.Clock()
running = True

def controller_tick(event_manager: EventManager):
    global running
    #Handle Input Events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            return 0
        event_manager.Post(event=event)
    return 1

def view_tick():
    pass

event_manager = EventManager()
card = Card("H", "A")
card_model = CardObject(card=card)
card_controller = CardController(card_model)
card_viewer = CardView(card_model)
event_manager.RegisterListener(card_controller)

while running:

    # handle input
    controller_tick(event_manager)

    # fill the screen with a color to wipe away anything from last frame
    screen.fill("green")

    # RENDER YOUR GAME HERE
    card_viewer.draw(screen=screen)

    # flip() the display to put your work on screen
    pygame.display.flip()

    clock.tick(60)  # limits FPS to 60

pygame.quit()